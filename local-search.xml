<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>你好</title>
    <link href="/2026/01/30/%E6%9C%AA%E5%91%BD%E5%90%8D/"/>
    <url>/2026/01/30/%E6%9C%AA%E5%91%BD%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<p>111</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>bug修复：GPU内存不足问题</title>
    <link href="/2026/01/30/bug%E4%BF%AE%E5%A4%8D/GPU%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E9%97%AE%E9%A2%98/"/>
    <url>/2026/01/30/bug%E4%BF%AE%E5%A4%8D/GPU%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs Bash">nvidia-smi<span class="hljs-built_in">kill</span> -9 34069  <span class="hljs-comment"># 占用最多的进程</span><span class="hljs-comment"># 或者使用pkill</span>pkill -f <span class="hljs-string">&quot;python&quot;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>bug修复</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bug修复</tag>
      
      <tag>GPU内存不足</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>expected str, bytes or os.PathLike object, not MultiplexedPath</title>
    <link href="/2026/01/30/bug%E4%BF%AE%E5%A4%8D/expected%20str,%20bytes%20or%20os.PathLike%20object,%20not%20MultiplexedPath/"/>
    <url>/2026/01/30/bug%E4%BF%AE%E5%A4%8D/expected%20str,%20bytes%20or%20os.PathLike%20object,%20not%20MultiplexedPath/</url>
    
    <content type="html"><![CDATA[<p>错误信息显示：</p><p><code>TypeError: expected str, bytes or os.PathLike object, not MultiplexedPath</code></p><p>这个错误是因为 <code>tn</code>库（text normalization库）在创建缓存目录时收到了一个 <code>MultiplexedPath</code>对象而不是字符串路径。</p><p><code>MultiplexedPath</code>是 HuggingFace 的 <code>huggingface_hub</code>库中的类型，通常用于处理多个缓存位置。</p><p>查看错误栈，问题出现在：</p><p><code>File &quot;/home/bysx/index-tts-vllm2/indextts/utils/front.py&quot;, line 111, in load</code></p><p><code>self.en_normalizer = NormalizerEn(overwrite_cache=False)</code></p><p>根据错误信息，现在的问题是在加载<code>en_normalizer</code>时，<code>cache_dir</code>参数的类型不正确。</p><p>在<code>NormalizerEn</code>的<code>init</code>中，<code>build_fst</code>方法尝试创建目录时，使用传入的<code>cache_dir</code>。</p><p>如果没有指定<code>cache_dir</code>，那么就会使用默认的缓存目录。</p><p>但是，如果默认的缓存目录是<code>MultiplexedPath</code>类型，就会有问题。</p><p>我们可以修改为：</p><p><code>self.en_normalizer = NormalizerEn(overwrite_cache=False, cache_dir=cache_dir)</code></p>]]></content>
    
    
    <categories>
      
      <category>bug修复</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bug修复</tag>
      
      <tag>TypeError</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Two Pointers  双指针</title>
    <link href="/2026/01/30/algorithm/Sorting%20&amp;%20Searching/Two%20Pointers%20%20%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2026/01/30/algorithm/Sorting%20&amp;%20Searching/Two%20Pointers%20%20%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Two-Pointers-双指针"><a href="#Two-Pointers-双指针" class="headerlink" title="Two Pointers 双指针"></a>Two Pointers 双指针</h1><p>双指针方法通过在数组中迭代两个指针来跟踪满足某些条件的索引。有两种常见的变体：</p><ol><li><p>两个指针从数组的两端开始，并相互移动。</p></li><li><p>两个指针以不同速度沿同一方向移动。这种变体被称为滑动窗口算法。</p></li></ol><h2 id="Sum-of-Two-Values"><a href="#Sum-of-Two-Values" class="headerlink" title="Sum of Two Values"></a>Sum of Two Values</h2><p><a href="https://cses.fi/problemset/task/1640">https://cses.fi/problemset/task/1640</a></p><h3 id="Solution-Sum-of-Two-Values"><a href="#Solution-Sum-of-Two-Values" class="headerlink" title="Solution - Sum of Two Values"></a>Solution - Sum of Two Values</h3><p>我们要找到两个索引 $i$ 和 $j$ ，使得 $a_i + a_j = x$。</p><h3 id="Implementation-实现"><a href="#Implementation-实现" class="headerlink" title="Implementation  实现"></a>Implementation  实现</h3><p><strong>Time Complexity:</strong> $\mathcal{O}(N \log N)$  时间复杂度： $\mathcal{O}(N \log N)$ </p><div class="code-wrapper"><pre><code class="hljs python">n, x = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())nums = [(<span class="hljs-built_in">int</span>(val), i) <span class="hljs-keyword">for</span> i, val <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">input</span>().split())]nums.sort()l = <span class="hljs-number">0</span>r = n - <span class="hljs-number">1</span><span class="hljs-keyword">while</span> l &lt; r:<span class="hljs-built_in">sum</span> = nums[l][<span class="hljs-number">0</span>] + nums[r][<span class="hljs-number">0</span>]<span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> == x:<span class="hljs-built_in">print</span>(nums[l][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, nums[r][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)exit()<span class="hljs-keyword">elif</span> <span class="hljs-built_in">sum</span> &lt; x:l += <span class="hljs-number">1</span><span class="hljs-keyword">else</span>:r -= <span class="hljs-number">1</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;IMPOSSIBLE&quot;</span>)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Sorting &amp; Searching</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Graph 图</title>
    <link href="/2026/01/30/algorithm/Graphs/Graph%20%E5%9B%BE/"/>
    <url>/2026/01/30/algorithm/Graphs/Graph%20%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="Graph-图"><a href="#Graph-图" class="headerlink" title="Graph 图"></a>Graph 图</h1><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><div class="code-wrapper"><pre><code class="hljs python">N, M = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())adj = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(M):u, v = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())adj[u].append(v)adj[v].append(u)u = <span class="hljs-number">1</span><span class="hljs-comment"># print number of vertices adjacent to u</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;deg(u) =&quot;</span>, <span class="hljs-built_in">len</span>(adj[u]))<span class="hljs-comment"># print all edges with u as an endpoint</span><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> adj[u]:<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&quot;</span> + <span class="hljs-built_in">str</span>(u) + <span class="hljs-string">&quot;, &quot;</span> + <span class="hljs-built_in">str</span>(v) + <span class="hljs-string">&quot;&#125;&quot;</span>)</code></pre></div><h3 id="cpp"><a href="#cpp" class="headerlink" title="cpp"></a>cpp</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> N, M;cin &gt;&gt; N &gt;&gt; M;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(N);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; M; ++i) &#123;<span class="hljs-type">int</span> u, v;cin &gt;&gt; u &gt;&gt; v;adj.<span class="hljs-built_in">at</span>(u).<span class="hljs-built_in">push_back</span>(v);adj.<span class="hljs-built_in">at</span>(v).<span class="hljs-built_in">push_back</span>(u);&#125;&#123;<span class="hljs-type">int</span> u = <span class="hljs-number">1</span>;<span class="hljs-comment">// print number of vertices adjacent to u</span>cout &lt;&lt; <span class="hljs-string">&quot;deg(u) = &quot;</span> &lt;&lt; adj.<span class="hljs-built_in">at</span>(u).<span class="hljs-built_in">size</span>() &lt;&lt; endl;<span class="hljs-comment">// print all edges with u as an endpoint</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : adj.<span class="hljs-built_in">at</span>(u)) cout &lt;&lt; <span class="hljs-string">&quot;&#123;&quot;</span> &lt;&lt; u &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot;&#125;&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;</code></pre></div><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><div class="code-wrapper"><pre><code class="hljs text">deg(u) = 3&#123;1, 3&#125;&#123;1, 4&#125;&#123;1, 5&#125;</code></pre></div><h1 id="Graph-Traversal-图遍历"><a href="#Graph-Traversal-图遍历" class="headerlink" title="Graph Traversal  图遍历"></a>Graph Traversal  图遍历</h1><p>图遍历算法按照一定的顺序访问图中的所有节点，并且在遍历过程中可以计算一些信息。两种常见的实现方式是深度优先搜索 depth first search (DFS) 和广度优先搜索 breadth first search (BFS) 。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><a href="Graph%20图.md">Graph 图</a></p><p><a href="使用递归的穷举搜索.md">使用递归的穷举搜索</a></p><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>深度优先搜索（DFS）是一种直接的图遍历技术。该算法从起始节点开始，通过图的边访问所有从起始节点可达的其他节点。</p><p>深度优先搜索只要发现新的节点，就会一直沿着图中的单一路径进行。之后，它会返回到之前的节点并开始探索图的其他部分。该算法会记录已访问的节点，以确保每个节点只被处理一次。</p><p><img src="dfs_demo.mp4" alt=""></p><p>在实现 DFS 时，我们通常使用一个递归函数来访问顶点，并使用一个数组来存储是否已经访问过某个顶点。</p><h3 id="cpp-1"><a href="#cpp-1" class="headerlink" title="cpp"></a>cpp</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">int</span> n = <span class="hljs-number">6</span>;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n);<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> current_node)</span> </span>&#123;<span class="hljs-keyword">if</span> (visited[current_node]) &#123; <span class="hljs-keyword">return</span>; &#125;visited[current_node] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : adj[current_node]) &#123; <span class="hljs-built_in">dfs</span>(neighbor); &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;adj[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;;adj[<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;adj[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">5</span>&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-comment">// iterate over all connected components in the graph</span><span class="hljs-keyword">if</span> (!visited[i]) &#123; <span class="hljs-built_in">dfs</span>(i); &#125;&#125;&#125;</code></pre></div><h3 id="python-1"><a href="#python-1" class="headerlink" title="python"></a>python</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> syssys.setrecursionlimit(<span class="hljs-number">10</span>**<span class="hljs-number">5</span>)  <span class="hljs-comment"># Python has a default recursion limit of 1000</span>n = <span class="hljs-number">6</span>visited = [<span class="hljs-literal">False</span>] * nadj = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]adj[<span class="hljs-number">0</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]adj[<span class="hljs-number">1</span>] = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]adj[<span class="hljs-number">2</span>] = [<span class="hljs-number">5</span>]<span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">current_node</span>):visited[current_node] = <span class="hljs-literal">True</span><span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> adj[current_node]:<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[neighbor]:dfs(neighbor)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[i]:dfs(i)</code></pre></div><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>在广度优先搜索中，我们按照顶点与起始顶点的距离顺序来遍历顶点。</p><p><img src="bfs_demo.mp4" alt=""></p><p>在实现 BFS 时，我们通常使用一个队列来跟踪下一个要访问的顶点。与 DFS 一样，我们也会维护一个数组来存储是否已经访问过某个顶点。</p><h3 id="cpp-2"><a href="#cpp-2" class="headerlink" title="cpp"></a>cpp</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-keyword">using</span> std::queue;<span class="hljs-keyword">using</span> std::vector;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n = <span class="hljs-number">6</span>;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n);<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n)</span></span>;adj[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;;adj[<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;adj[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">5</span>&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-comment">// iterate over all connected components in the graph</span><span class="hljs-keyword">if</span> (!visited[i]) &#123;queue&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push</span>(i);visited[i] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> current_node = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : adj[current_node]) &#123;<span class="hljs-keyword">if</span> (!visited[neighbor]) &#123;visited[neighbor] = <span class="hljs-literal">true</span>;q.<span class="hljs-built_in">push</span>(neighbor);&#125;&#125;&#125;&#125;&#125;&#125;</code></pre></div><h3 id="python-2"><a href="#python-2" class="headerlink" title="python"></a>python</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> dequen = <span class="hljs-number">6</span>adj = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]visited = [<span class="hljs-literal">False</span>] * nadj[<span class="hljs-number">0</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]adj[<span class="hljs-number">1</span>] = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]adj[<span class="hljs-number">2</span>] = [<span class="hljs-number">5</span>]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<span class="hljs-comment"># iterate over all connected components in the graph</span><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[i]:q = deque([i])<span class="hljs-keyword">while</span> q:node = q.popleft()visited[node] = <span class="hljs-literal">True</span><span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> adj[node]:<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[neighbor]:q.append(neighbor)</code></pre></div><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="Connected-Components-连通分量"><a href="#Connected-Components-连通分量" class="headerlink" title="Connected Components  连通分量"></a>Connected Components  连通分量</h3><p><a href="https://cses.fi/problemset/task/1666">https://cses.fi/problemset/task/1666</a></p><p>一个连通分量是无向图中一个最大的连通节点集合。换句话说，两个节点位于同一个连通分量中，当且仅当它们可以通过图中的边相互到达。</p><p>在上述重点问题中，目标是添加尽可能少的边，使得整个图形成一个单一的连通分量。</p><h4 id="Solution-Building-Roads"><a href="#Solution-Building-Roads" class="headerlink" title="Solution - Building Roads"></a>Solution - Building Roads</h4><p>请注意，每条边会将连通分量的数量减少零个或一个。因此，您必须至少添加 $C-1$ 条边，其中 $C$ 是输入图中的连通分量数量。</p><p>为了计算 $C$ ，可以遍历每个节点。如果该节点尚未被访问，则使用 DFS 或 BFS 访问该节点及其所在连通分量的所有其他节点。然后 $C$ 等于我们执行访问操作的次数。</p><p>有许多有效的方法可以选择 $C−1$ 条新的道路来建设。一种方法是为每个 $C$ 连通分量选择一个代表节点，并将它们连接成一条线。</p><h4 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h4><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> syssys.setrecursionlimit(<span class="hljs-number">10</span> ** <span class="hljs-number">6</span>)n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())adj = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]visited = [<span class="hljs-literal">False</span>] * n<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):    u, v = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())    u -= <span class="hljs-number">1</span>    v -= <span class="hljs-number">1</span>    adj[u].append(v)    adj[v].append(u)c = <span class="hljs-number">0</span>connect = []<span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>):    visited[node] = <span class="hljs-literal">True</span>    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> adj[node]:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[v]:            dfs(v)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[i]:        c += <span class="hljs-number">1</span>        connect.append(i)        dfs(i)<span class="hljs-built_in">print</span>(c-<span class="hljs-number">1</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(c-<span class="hljs-number">1</span>):    <span class="hljs-built_in">print</span>(connect[i]+<span class="hljs-number">1</span>, connect[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>)</code></pre></div><h4 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h4><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> dequen, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())adj = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]visited = [<span class="hljs-literal">False</span>] * n<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):    u, v = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())    u -= <span class="hljs-number">1</span>    v -= <span class="hljs-number">1</span>    adj[u].append(v)    adj[v].append(u)c = <span class="hljs-number">0</span>connect = []    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[i]:        c += <span class="hljs-number">1</span>        connect.append(i)        q = deque([i])        <span class="hljs-keyword">while</span> q:            node = q.popleft()            visited[node] = <span class="hljs-literal">True</span>            <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> adj[node]:                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[v]:                    q.append(v)<span class="hljs-built_in">print</span>(c-<span class="hljs-number">1</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(c-<span class="hljs-number">1</span>):    <span class="hljs-built_in">print</span>(connect[i]+<span class="hljs-number">1</span>, connect[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>)</code></pre></div><h3 id="Graph-Two-Coloring-图的二色染色"><a href="#Graph-Two-Coloring-图的二色染色" class="headerlink" title="Graph Two-Coloring  图的二色染色"></a>Graph Two-Coloring  图的二色染色</h3><p><a href="https://cses.fi/problemset/task/1668">https://cses.fi/problemset/task/1668</a></p><p>图的二色化指的是为图中的每个节点分配一个布尔值，该值由边的配置决定。最常见的二色图例子是二分图，在这种图中，每条边连接两个颜色不同的节点。</p><p>在上述重点问题中，目标是将图中的每个节点（朋友）分配到两种颜色（队伍）之一，满足边（友谊）连接两个颜色不同的节点的约束条件。换句话说，我们需要检查输入是否为二分图，如果是，则输出一种有效的着色方案。</p>]]></content>
    
    
    <categories>
      
      <category>Graphs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dfs</tag>
      
      <tag>bfs</tag>
      
      <tag>图搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用递归的穷举搜索</title>
    <link href="/2026/01/30/algorithm/Graphs/%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E7%9A%84%E7%A9%B7%E4%B8%BE%E6%90%9C%E7%B4%A2/"/>
    <url>/2026/01/30/algorithm/Graphs/%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E7%9A%84%E7%A9%B7%E4%B8%BE%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="使用递归的穷举搜索"><a href="#使用递归的穷举搜索" class="headerlink" title="使用递归的穷举搜索"></a>使用递归的穷举搜索</h1><h2 id="Subsets-子集"><a href="#Subsets-子集" class="headerlink" title="Subsets  子集"></a>Subsets  子集</h2><p><a href="https://cses.fi/problemset/task/1623">https://cses.fi/problemset/task/1623</a></p><h3 id="递归生成子集"><a href="#递归生成子集" class="headerlink" title="递归生成子集"></a>递归生成子集</h3><p>编写一个递归函数，遍历所有可能的分组方式。</p><p>在某个索引处，我们要么将 $\texttt{apple}_i$​ 添加到第一个集合，要么添加到第二个集合，存储两个总和 $\texttt{sum}_1$​ 和 $\texttt{sum}_2$​ ，分别表示每个集合中值的总和。</p><p>一旦到达数组的末尾，我们返回这两个总和的差值。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<span class="hljs-type">int</span> n;vector&lt;ll&gt; apples;<span class="hljs-function">ll <span class="hljs-title">sol</span><span class="hljs-params">(<span class="hljs-type">int</span> ind, ll sum1, ll sum2)</span></span>&#123;    <span class="hljs-keyword">if</span>(ind == n)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(sum1 - sum2);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">sol</span>(ind<span class="hljs-number">+1</span>, sum1 + apples[ind], sum2),                <span class="hljs-built_in">sol</span>(ind<span class="hljs-number">+1</span>, sum1, sum2 + apples[ind]));&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);    cin &gt;&gt; n;    apples.<span class="hljs-built_in">resize</span>(n);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;        cin &gt;&gt; apples[i];    &#125;    ll ans = <span class="hljs-built_in">sol</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    cout &lt;&lt; ans;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="Permutations-排列"><a href="#Permutations-排列" class="headerlink" title="Permutations  排列"></a>Permutations  排列</h2><ul><li>排列是对一组元素的重新排序。</li><li>Lexicographical Order  字典序</li></ul><p><a href="https://cses.fi/problemset/task/1622">https://cses.fi/problemset/task/1622</a></p><h3 id="Solution-1：递归生成排列"><a href="#Solution-1：递归生成排列" class="headerlink" title="Solution 1：递归生成排列"></a>Solution 1：递归生成排列</h3><p>我们将使用递归函数 $\texttt{search}$ 来找出字符串 $s$ 的所有排列。首先，记录 $s$ 中每个字符的数量。对于每个函数调用，将一个可用字符添加到当前字符串中，并调用 $\texttt{search}$ 以该字符串作为参数。当当前字符串的长度与 $s$ 相同时，我们找到了一个排列，可以将其添加到 $\texttt{perms}$ 的列表中。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;string str;vector&lt;string&gt; ans;<span class="hljs-type">int</span> char_count[<span class="hljs-number">26</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">search</span><span class="hljs-params">(string curr)</span></span>&#123;    <span class="hljs-keyword">if</span>(curr.<span class="hljs-built_in">size</span>() == str.<span class="hljs-built_in">size</span>())&#123;        ans.<span class="hljs-built_in">push_back</span>(curr);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)&#123;        <span class="hljs-keyword">if</span>(char_count[i] &gt; <span class="hljs-number">0</span>)&#123;            char_count[i]--;            <span class="hljs-built_in">search</span>(curr + (<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;a&#x27;</span> + i));            char_count[i]++;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);    cin &gt;&gt; str;    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: str)&#123;        char_count[c - <span class="hljs-string">&#x27;a&#x27;</span>] ++;    &#125;    <span class="hljs-built_in">search</span>(<span class="hljs-string">&quot;&quot;</span>);    cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    <span class="hljs-keyword">for</span>(string str: ans)&#123;        cout &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="Solution-2：使用-next-permutation-生成排列"><a href="#Solution-2：使用-next-permutation-生成排列" class="headerlink" title="Solution 2：使用 next_permutation 生成排列"></a>Solution 2：使用 <code>next_permutation</code> 生成排列</h3><p>或者，我们也可以直接使用 <code>next_permutation()</code> 函数。该函数接受一个范围，并将其修改为下一个更大的排列。如果没有更大的排列，它将返回 false。</p><p>每次调用 <code>next_permutation</code> 在遍历所有 $N!$ 大小的排列时，平均情况下会进行常数次交换。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);    string s;    cin &gt;&gt; s;    <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());    vector&lt;string&gt; ans;    <span class="hljs-keyword">do</span>&#123;        ans.<span class="hljs-built_in">push_back</span>(s);    &#125; <span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>()));    cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    <span class="hljs-keyword">for</span>(string str: ans)&#123;        cout &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="Backtracking-回溯法"><a href="#Backtracking-回溯法" class="headerlink" title="Backtracking  回溯法"></a>Backtracking  回溯法</h2><p><a href="https://cses.fi/problemset/task/1624">https://cses.fi/problemset/task/1624</a></p><h3 id="Solution-1：使用-next-permutation生成排列"><a href="#Solution-1：使用-next-permutation生成排列" class="headerlink" title="Solution 1：使用 next_permutation生成排列"></a>Solution 1：使用 <code>next_permutation</code>生成排列</h3><p>一种检查所有 $\binom{64}{8}$ 种皇后组合的暴力解法将有超过 40 亿种情况需要检查，因此会太慢。</p><p>我们必须更聪明地进行暴力枚举：注意我们可以直接生成排列，使得任何两个皇后都不在同一行或同一列上互相攻击。</p><p>由于不能有两个皇后在同一列，因此只需要在每一行放置一个皇后。接下来需要确定的是如何变化每个皇后所在的行。这可以通过生成所有排列来实现，其中数字表示每个皇后所在的行。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">int</span> n = <span class="hljs-number">8</span>;vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;<span class="hljs-built_in">blocked</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n));<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">queens</span><span class="hljs-params">(n)</span></span>;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;        <span class="hljs-type">int</span> j = queens[i];        <span class="hljs-keyword">if</span>(blocked[i][j])&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">taken1</span><span class="hljs-params">(n * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;        <span class="hljs-type">int</span> sum = queens[i] + i;        <span class="hljs-keyword">if</span>(taken1[sum])&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        taken1[sum] = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">taken2</span><span class="hljs-params">(n * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;        <span class="hljs-type">int</span> diff = queens[i] - i + n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(taken2[diff])&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        taken2[diff] = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;        string s;        cin &gt;&gt; s;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;            <span class="hljs-keyword">if</span>(s[j] == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;                blocked[i][j] = <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span>&#123;                blocked[i][j] = <span class="hljs-literal">false</span>;            &#125;        &#125;    &#125;        <span class="hljs-built_in">iota</span>(queens.<span class="hljs-built_in">begin</span>(), queens.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">do</span>&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>())&#123;            ans++;        &#125;    &#125; <span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(queens.<span class="hljs-built_in">begin</span>(), queens.<span class="hljs-built_in">end</span>()));    cout &lt;&lt; ans;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="Solution-2：使用回溯法"><a href="#Solution-2：使用回溯法" class="headerlink" title="Solution 2：使用回溯法"></a>Solution 2：使用回溯法</h3><p>回溯算法从一个空解开始，逐步扩展解。搜索递归地遍历所有可能的解的构造方式。</p><p>由于边界条件较小，我们可以递归地回溯所有放置皇后的方式，并存储棋盘的当前状态。</p><p>在每一层，我们尝试在所有未被阻挡或未被其他皇后攻击的格子上放置皇后。完成这一步后，我们递归调用，然后移除该皇后并回溯。</p><p>最后，当我们将八个皇后全部放置完毕时，我们增加答案计数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">int</span> n = <span class="hljs-number">8</span>;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">blocked</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">row_taken</span><span class="hljs-params">(n)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">diag1</span><span class="hljs-params">(<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">diag2</span><span class="hljs-params">(<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">search_queens</span><span class="hljs-params">(<span class="hljs-type">int</span> j)</span></span>&#123;    <span class="hljs-keyword">if</span>(j == n)&#123;        ans++;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;        <span class="hljs-keyword">if</span>(!blocked[i][j] &amp;&amp; !row_taken[i] &amp;&amp; !diag1[i+j] &amp;&amp; ! diag2[i-j+n<span class="hljs-number">-1</span>])&#123;            row_taken[i] = diag1[i+j] = diag2[i-j+n<span class="hljs-number">-1</span>] = <span class="hljs-literal">true</span>;            <span class="hljs-built_in">search_queens</span>(j<span class="hljs-number">+1</span>);            row_taken[i] = diag1[i+j] = diag2[i-j+n<span class="hljs-number">-1</span>] = <span class="hljs-literal">false</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;        string s;        cin &gt;&gt; s;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;            blocked[i][j] = s[j] == <span class="hljs-string">&#x27;*&#x27;</span>;        &#125;    &#125;    <span class="hljs-built_in">search_queens</span>(<span class="hljs-number">0</span>);    cout &lt;&lt; ans;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Graphs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>穷举搜索</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2026/01/29/hello-world/"/>
    <url>/2026/01/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2025/12/19/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2025/12/19/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Queues-队列"><a href="#Queues-队列" class="headerlink" title="Queues  队列"></a>Queues  队列</h1><p>队列是一种先进先出 First In First Out（FIFO）的数据结构，支持三种操作，所有操作的时间复杂度均为 $\mathcal{O}(1)$ 。</p><p><code>std::queue</code></p><ul><li><p><code>push</code>: 在队列的末尾插入</p></li><li><p><code>pop</code>: 从队列的前端删除</p></li><li><p><code>front</code>: 获取前端元素但不将其移除</p></li></ul><div class="code-wrapper"><pre><code class="hljs cpp">queue&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);                  <span class="hljs-comment">// [1]</span>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);                  <span class="hljs-comment">// [1, 3]</span>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">4</span>);                  <span class="hljs-comment">// [1, 3, 4]</span>q.<span class="hljs-built_in">pop</span>();                    <span class="hljs-comment">// [3, 4]</span>cout &lt;&lt; q.<span class="hljs-built_in">front</span>() &lt;&lt; endl;  <span class="hljs-comment">// 3</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queueq = Queue()           <span class="hljs-comment"># []</span>q.put(<span class="hljs-number">1</span>)              <span class="hljs-comment"># [1]</span>q.put(<span class="hljs-number">2</span>)              <span class="hljs-comment"># [1, 2]</span>v = q.queue[<span class="hljs-number">0</span>]        <span class="hljs-comment"># v = 1, q = [1, 2]</span>v = q.get()           <span class="hljs-comment"># v = 1, q = [2]</span>v = q.get()           <span class="hljs-comment"># v = 2, q = []</span>v = q.get()           <span class="hljs-comment"># 代码会一直等待，导致TLE错误</span></code></pre></div><h1 id="Deques-双端队列"><a href="#Deques-双端队列" class="headerlink" title="Deques  双端队列"></a>Deques  双端队列</h1><p>一个双端队列（通常发音为“deck”）代表双端队列，它是栈和队列的结合，支持在双端队列的前后两端进行插入和删除操作。</p><p><code>std::deque</code></p><p>添加和删除的四种方法是 <code>push_back</code> , <code>pop_back</code> , <code>push_front</code> , 和 <code>pop_front</code> 。</p><div class="code-wrapper"><pre><code class="hljs cpp">deque&lt;<span class="hljs-type">int</span>&gt; d;d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// [3]</span>d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">4</span>);  <span class="hljs-comment">// [4, 3]</span>d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">7</span>);   <span class="hljs-comment">// [4, 3, 7]</span>d.<span class="hljs-built_in">pop_front</span>();    <span class="hljs-comment">// [3, 7]</span>d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// [1, 3, 7]</span>d.<span class="hljs-built_in">pop_back</span>();     <span class="hljs-comment">// [1, 3]</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs python">d = collections.deque()d.appendleft(<span class="hljs-number">3</span>)  <span class="hljs-comment"># [3]</span>d.appendleft(<span class="hljs-number">4</span>)  <span class="hljs-comment"># [4, 3]</span>d.append(<span class="hljs-number">7</span>)  <span class="hljs-comment"># [4, 3, 7]</span>d.popleft()  <span class="hljs-comment"># [3, 7]</span>d.appendleft(<span class="hljs-number">1</span>)  <span class="hljs-comment"># [1, 3, 7]</span>d.pop()  <span class="hljs-comment"># [1, 3]</span></code></pre></div><p>你也可以像用数组的 <code>[]</code> 运算符一样，以常数时间访问双端队列中的元素。例如，要访问双端队列 $\texttt{dq}$ 中的 $i$ 个元素，可以使用 $\texttt{dq}[i]$ 。</p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>use_python</title>
    <link href="/2025/12/16/algorithm/use_python/"/>
    <url>/2025/12/16/algorithm/use_python/</url>
    
    <content type="html"><![CDATA[<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><h2 id="读入单行"><a href="#读入单行" class="headerlink" title="读入单行"></a>读入单行</h2><div class="code-wrapper"><pre><code class="hljs python">a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<span class="hljs-built_in">print</span>(a+b)</code></pre></div><h2 id="读入多行"><a href="#读入多行" class="headerlink" title="读入多行"></a>读入多行</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sys.stdin:    list1 = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, line.strip().split())    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>(list1))</code></pre></div><h2 id="readline-、readlines-和-read-区别"><a href="#readline-、readlines-和-read-区别" class="headerlink" title="readline() 、readlines() 和 read() 区别"></a><code>readline()</code> 、<code>readlines()</code> 和 <code>read()</code> 区别</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<span class="hljs-comment"># 输入：</span><span class="hljs-comment"># Hello</span><span class="hljs-comment"># World</span><span class="hljs-comment"># !</span><span class="hljs-comment"># 使用 readline()</span>line1 = sys.stdin.readline()  <span class="hljs-comment"># &quot;Hello\n&quot;</span>line2 = sys.stdin.readline()  <span class="hljs-comment"># &quot;World\n&quot;</span>line3 = sys.stdin.readline()  <span class="hljs-comment"># &quot;!\n&quot;</span>line4 = sys.stdin.readline()  <span class="hljs-comment"># &quot;&quot;</span><span class="hljs-comment"># 使用 readlines()</span>lines = sys.stdin.readlines()  <span class="hljs-comment"># [&quot;Hello\n&quot;, &quot;World\n&quot;, &quot;!\n&quot;]</span><span class="hljs-comment"># 使用 read()</span>content = sys.stdin.read()  <span class="hljs-comment"># &quot;Hello\nWorld\n!\n&quot;</span></code></pre></div><h2 id="strip-函数"><a href="#strip-函数" class="headerlink" title="strip() 函数"></a><code>strip()</code> 函数</h2><div class="code-wrapper"><pre><code class="hljs python">s = <span class="hljs-string">&quot;  hello  \n\t&quot;</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">repr</span>(s.rstrip()))  <span class="hljs-comment"># 移除右侧空白字符 → &quot;&#x27;  hello&#x27;&quot;</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">repr</span>(s.lstrip()))  <span class="hljs-comment"># 移除左侧空白字符 → &quot;&#x27;hello  \n\t&#x27;&quot;</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">repr</span>(s.strip()))   <span class="hljs-comment"># 移除两侧空白字符 → &quot;&#x27;hello&#x27;&quot;</span></code></pre></div><h2 id="split-函数"><a href="#split-函数" class="headerlink" title="split() 函数"></a><code>split()</code> 函数</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.split(sep=<span class="hljs-literal">None</span>, maxsplit=-<span class="hljs-number">1</span>)</code></pre></div><ul><li><strong>sep</strong>：分隔符，默认为任何空白字符</li><li><strong>maxsplit</strong>：最大分割次数，默认为 -1（不限制）</li></ul>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05_Cow_Gymnastics</title>
    <link href="/2025/11/20/algorithm/Complete_Search/05_Cow_Gymnastics/"/>
    <url>/2025/11/20/algorithm/Complete_Search/05_Cow_Gymnastics/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>USACO 2019 December Contest, Bronze Problem 1. Cow Gymnastics<br><a href="https://usaco.org/index.php?page=viewproblem2&amp;cpid=963">https://usaco.org/index.php?page=viewproblem2&amp;cpid=963</a></p><p>奶牛们正在进行体操训练，Bessie 记录了 K 次训练课中 N 头奶牛的排名。我们需要找出所有”一致”的奶牛对，即其中一头奶牛在<strong>每次</strong>训练课中都表现得比另一头要好。</p><p>$0≤N≤20，1≤K≤10$</p><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p>输入：</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><span class="hljs-symbol">4 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-symbol">4 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><span class="hljs-symbol">4 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span></code></pre></div><p>输出 :</p><div class="code-wrapper"><pre><code class="hljs">4</code></pre></div><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>对于任意一对奶牛 $(i, j)$，它们的关系可能有三种情况：</p><ol><li>$i$ 在每次训练课中都比 $j$ 表现好</li><li>$j$ 在每次训练课中都比 $i$ 表现好</li><li>互有胜负（有时 $i$ 比 $j$ 好，有时 $j$ 比 $i$ 好）<br>只有前两种情况才符合”一致”的定义。</li></ol><p>我们可以创建一个二维布尔数组，该数组表示在任何时间点奶牛 $A$ 的排名是否高于奶牛 $B$ 。在读取完所有排名后，对于所有 $\frac{N(N-1)}{2}$ 对，我们设置 $b[A][B]=\text{true}$ 。</p><p>然后我们遍历所有对，检查它们是否满足条件。如果两个都为真，那么这对在某个时间点改变了排名顺序。如果只有一个为真，那么这对保持了一致的顺序。因此，需要 $b[A][B]$ 和 $b[B][A]$ 中至少有一个为真，可以用异或操作 <code>a[i][j] ^ a[j][i]</code> 来检测。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：$O(K×N²)$<br>空间复杂度：$O(N²)$ </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;gymnastics.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;gymnastics.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);    <span class="hljs-type">int</span> k, n;    cin &gt;&gt; k &gt;&gt; n;        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;<span class="hljs-built_in">a</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n));    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> tt = <span class="hljs-number">0</span>; tt &lt; k; tt++)&#123;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp; x:b)&#123;            cin &gt;&gt; x;            x--;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">+1</span>; j &lt; n; j++)&#123;                a[b[i]][b[j]] = <span class="hljs-literal">true</span>;            &#125;        &#125;    &#125;        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">+1</span>; j &lt; n; j++)&#123;            ans += a[i][j] ^ a[j][i];        &#125;    &#125;    cout &lt;&lt; ans;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Complete_Search</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04_Counting_Liars</title>
    <link href="/2025/11/20/algorithm/Complete_Search/04_Counting_Liars/"/>
    <url>/2025/11/20/algorithm/Complete_Search/04_Counting_Liars/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>USACO 2022 US Open Contest, Bronze Problem 2. Counting Liars<br><a href="https://usaco.org/index.php?page=viewproblem2&amp;cpid=1228">https://usaco.org/index.php?page=viewproblem2&amp;cpid=1228</a></p><p>农夫约翰有 $N$ 头奶牛（不包括 Bessie）。每头牛给出一条关于 Bessie 躲藏位置的陈述：</p><ul><li>若某头牛说 $L$ ：意思是 _Bessie 的位置 $≤ p$</li><li>若某头牛说 $G$ ：意思是 _Bessie 的位置 $≥ p$</li></ul><p>$0≤p≤10^9，1≤N≤1000$</p><p>可能并非所有牛都说了真话，你需要找出至少要让多少头牛说谎，才能使得剩下的陈述存在某个位置 $x$ 满足所有剩余陈述。</p><p><strong>输出最少必须说谎的牛数。</strong></p><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><h3 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 1"></a>样例 1</h3><p>输入：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">2</span><span class="hljs-attribute">G</span> <span class="hljs-number">3</span><span class="hljs-attribute">L</span> <span class="hljs-number">5</span></code></pre></div><p>代表：</p><ul><li>Cow1：Bessie ≥ 3</li><li>Cow2：Bessie ≤ 5<br>显然 3 ≤ Bessie ≤ 5 有解，所以 <strong>0</strong> 头说谎。</li></ul><p>输出 :</p><div class="code-wrapper"><pre><code class="hljs">0</code></pre></div><h3 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 2"></a>样例 2</h3><p>输入：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">2</span><span class="hljs-attribute">G</span> <span class="hljs-number">3</span><span class="hljs-attribute">L</span> <span class="hljs-number">2</span></code></pre></div><p>代表：</p><ul><li>Bessie ≥ 3</li><li>Bessie ≤ 2<br>没有位置能同时满足，必须至少删除一条陈述 → 答案是 <strong>1</strong>。</li></ul><p>输出 :</p><div class="code-wrapper"><pre><code class="hljs">1</code></pre></div><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>在我们对输入进行排序后，一个重要的观察是，如果贝西位于位置 $x$ ，那么说谎的牛的数量就是所有位置小于 $x$ 且说 “L” 的牛，加上所有位置大于 $x$ 且说 “G” 的牛。</p><p>也就是说，如果把所有 $p$ 排好序，只需考虑每个 $p_i$ 本身作为分界。</p><p>因此，我们可以遍历每头牛的位置，通过使用正向循环和反向循环来计算说谎者的总数。</p><p>答案是我们在所有遍历过的位置中最小的说谎者数量。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);        <span class="hljs-type">int</span> n; cin &gt;&gt; n;    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt;&gt; <span class="hljs-built_in">cow</span>(n);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;        cin &gt;&gt; cow[i].second &gt;&gt; cow[i].first;    &#125;    <span class="hljs-built_in">sort</span>(cow.<span class="hljs-built_in">begin</span>(), cow.<span class="hljs-built_in">end</span>());        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left_lying</span><span class="hljs-params">(n)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;        left_lying[i] = left_lying[i<span class="hljs-number">-1</span>];        <span class="hljs-keyword">if</span>(cow[i<span class="hljs-number">-1</span>].second == <span class="hljs-string">&#x27;L&#x27;</span>)&#123;            left_lying[i] ++;        &#125;    &#125;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right_lying</span><span class="hljs-params">(n)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;        right_lying[i] = right_lying[i<span class="hljs-number">+1</span>];        <span class="hljs-keyword">if</span>(cow[i<span class="hljs-number">+1</span>].second == <span class="hljs-string">&#x27;G&#x27;</span>)&#123;            right_lying[i]++;        &#125;    &#125;        <span class="hljs-type">int</span> ans = n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;        ans = <span class="hljs-built_in">min</span>(ans, left_lying[i] + right_lying[i]);    &#125;    cout &lt;&lt; ans;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Complete_Search</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02_Diamond_Collector</title>
    <link href="/2025/10/29/algorithm/Complete_Search/02_Diamond_Collector/"/>
    <url>/2025/10/29/algorithm/Complete_Search/02_Diamond_Collector/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>USACO 2016 US Open Contest, Bronze Problem 1. Diamond Collector<br><a href="https://usaco.org/index.php?page=viewproblem2&amp;cpid=639">https://usaco.org/index.php?page=viewproblem2&amp;cpid=639</a></p><p>给定长度为 $N$ 的数组和 $K$ ，输出 $subsequence$ 最长的长度，要求 $subsequence$ 中任意两数之差不超过 $K$ 。</p><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p>input :</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><span class="hljs-number">1</span><span class="hljs-number">6</span><span class="hljs-number">4</span><span class="hljs-number">3</span><span class="hljs-number">1</span></code></pre></div><p>output :</p><div class="code-wrapper"><pre><code class="hljs">4</code></pre></div><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>遍历数组中每个数 $x$ ，遍历搜索数组中有几个 $y$ 使得 $y$ 大于 $x$ 且 $y - x &lt;= K$ ，$ans$ 更新为最长的长度。</p><p>$y$ 和 $x$ 之差不能使用 $abs$ 绝对值。因为这样会导致一个 $y$ 比 $x$ 大 $K$ ，另一个 $y$ 比 $x$ 小 $K$，那么这两个 $y$ 的差值大于 $K$，导致答案错误。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;diamond.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;diamond.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);    <span class="hljs-type">int</span> n, k;    cin &gt;&gt; n &gt;&gt; k;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp; x:a) cin &gt;&gt; x;    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x: a)&#123;        <span class="hljs-type">int</span> now = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y:a)&#123;            <span class="hljs-keyword">if</span>(y &gt;= x &amp;&amp; y - x &lt;= k) now++;        &#125;        ans = <span class="hljs-built_in">max</span>(ans, now);    &#125;    cout &lt;&lt; ans;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Complete_Search</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01_Milk Pails</title>
    <link href="/2025/10/29/algorithm/Complete_Search/01_Milk%20Pails/"/>
    <url>/2025/10/29/algorithm/Complete_Search/01_Milk%20Pails/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>USACO 2016 February Contest, Bronze Problem 1. Milk Pails<br><a href="https://usaco.org/index.php?page=viewproblem2&amp;cpid=615">https://usaco.org/index.php?page=viewproblem2&amp;cpid=615</a></p><p>给定 $X, Y, M$ ，求 $aX + bY$ 不超过 $M$ 的最大值，$a, b$ 任意。</p><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p>输入</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">17 </span><span class="hljs-number">25</span> <span class="hljs-number">77</span></code></pre></div><p>输出</p><div class="code-wrapper"><pre><code class="hljs">76</code></pre></div><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>$a$ 的范围为 $0$ 至 $M/X$  ，$b$ 的范围为 $0$ 至 $M/Y$ 。<br>遍历 $a$ 和 $b$ ，如果 $aX + bY$ 不超过 $M$ ，则 $ans$ 更新为最大值。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;pails.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;pails.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);    <span class="hljs-type">int</span> x, y, m;    cin &gt;&gt; x &gt;&gt; y &gt;&gt; m;    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m / x; i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m / y; j++)&#123;            <span class="hljs-type">int</span> now = i * x + j * y;            <span class="hljs-keyword">if</span>(now &lt;= m)&#123;                ans = <span class="hljs-built_in">max</span>(now, ans);            &#125;        &#125;    &#125;    cout &lt;&lt; ans;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Complete_Search</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cf</title>
    <link href="/2025/09/03/algorithm/cf/"/>
    <url>/2025/09/03/algorithm/cf/</url>
    
    <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LOCAL</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;algo/debug.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(...) 42</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);    <span class="hljs-comment">//freopen(&quot;filename.in&quot;, &quot;r&quot;, stdin);</span>    <span class="hljs-comment">//freopen(&quot;filename.out&quot;, &quot;w&quot;, stdout);</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h1 id="一些算法"><a href="#一些算法" class="headerlink" title="一些算法"></a>一些算法</h1><p>对于任意两个正整数 n，m 的最小公倍数为 n×m / gcd(n,m)，其中 gcd(n,m) 为 n 和 m 的最大公约数。</p><p>subarray是截取数组中连续的一段子数组。 subsequence是序列中不连续的一段子序列</p><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p>int32的范围是2e9<br>int64是2e18</p><p>题目给的时限是1s，时间复杂度在1e7到1e8之间</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 自动初始化为全0</span><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<span class="hljs-comment">// 改变长度</span>v.<span class="hljs-built_in">resize</span>(n);<span class="hljs-comment">// 输入序列</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; x: a) cin &gt;&gt; x;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) a.<span class="hljs-built_in">push_back</span>(i);<span class="hljs-comment">// 检查序列中是否存在 连续重复 的元素</span><span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">unique</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>()) != a.<span class="hljs-built_in">end</span>()) cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;<span class="hljs-comment">// 返回最后一个字符</span>string.<span class="hljs-built_in">back</span>()a.<span class="hljs-built_in">back</span>()<span class="hljs-comment">// 输出空格</span>cout &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n<span class="hljs-number">-1</span>];<span class="hljs-comment">// 倒序排列</span><span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">rbegin</span>(), s.<span class="hljs-built_in">rend</span>());<span class="hljs-comment">// 反转</span><span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<span class="hljs-comment">// 添加到序列的末尾</span>a.<span class="hljs-built_in">push_back</span>(x)<span class="hljs-comment">// 打印序列</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x: a) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[x == a.<span class="hljs-built_in">back</span>()];<span class="hljs-comment">// 找到数组 `a` 中的最大值 `mx`</span><span class="hljs-type">int</span> mx = *<span class="hljs-built_in">max_element</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());</code></pre></div><h1 id="华为HR"><a href="#华为HR" class="headerlink" title="华为HR"></a>华为HR</h1><p>leetcode：熟悉题型和算法，各类型的题选做10-15道（保底5-8道）<br>针对薄弱知识点查缺补漏题号：<br>字符串：3，49，30<br>线性表:86，16，27，732<br>队列:641，406，899<br>栈:946，116，117，895<br>哈希表:61，729，25，554<br>dfs：105，112，98，494，547，1254<br>bfs：1091，1129，102，101，752<br>动态规划类题目也可以适当熟悉</p><p>常考知识点：<br>基本操作：输入输出处理（重点），字符串操作与ASCii码（重点）<br>数据结构：一维数组，栈，队列<br>编程思想：暴力破解（重点），递归<br>算法：排列组合（重点），快速排序（重点），二分查找，位运算，滑动窗口，深度优先搜索（进阶），搜索回溯（进阶）</p><p>注意：</p><ol><li>需要开摄像头，不能访问其他网页或者查找资源，可以在本地IDE调试好后拷贝到牛客网上再调试</li><li>多刷一下各类算法题，难度中等及以上，在牛客有或者力扣上刷都可以</li><li>熟悉牛客网考试环境，和本地环境IDE、力扣有差异</li><li>ACM模式自己写输入输出</li><li>三道题分值100、200、300，及格150分</li></ol><p>这个公众号可以看一下题目类型适应一下</p><p><a href="https://www.acmcoder.com/#/practice/company">https://www.acmcoder.com/#/practice/company</a></p><p><a href="https://mp.weixin.qq.com/s/1RuKNdSYLKRja0NlWikRnA">https://mp.weixin.qq.com/s/1RuKNdSYLKRja0NlWikRnA</a></p><p><a href="https://mp.weixin.qq.com/s/pY0EHj0eVLgIfkDiJb0RSQ">https://mp.weixin.qq.com/s/pY0EHj0eVLgIfkDiJb0RSQ</a></p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
