<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>图搜索算法</title>
    <link href="/2026/01/30/Graphs/Graph%20%E5%9B%BE/"/>
    <url>/2026/01/30/Graphs/Graph%20%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="graph-图">Graph 图</h1><h2 id="邻接表">邻接表</h2><h3 id="python">python</h3><div class="code-wrapper"><pre><code class="hljs python">N, M = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())adj = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(M):u, v = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())adj[u].append(v)adj[v].append(u)u = <span class="hljs-number">1</span><span class="hljs-comment"># print number of vertices adjacent to u</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;deg(u) =&quot;</span>, <span class="hljs-built_in">len</span>(adj[u]))<span class="hljs-comment"># print all edges with u as an endpoint</span><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> adj[u]:<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&quot;</span> + <span class="hljs-built_in">str</span>(u) + <span class="hljs-string">&quot;, &quot;</span> + <span class="hljs-built_in">str</span>(v) + <span class="hljs-string">&quot;&#125;&quot;</span>)</code></pre></div><h3 id="cpp">cpp</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> N, M;cin &gt;&gt; N &gt;&gt; M;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(N);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; M; ++i) &#123;<span class="hljs-type">int</span> u, v;cin &gt;&gt; u &gt;&gt; v;adj.<span class="hljs-built_in">at</span>(u).<span class="hljs-built_in">push_back</span>(v);adj.<span class="hljs-built_in">at</span>(v).<span class="hljs-built_in">push_back</span>(u);&#125;&#123;<span class="hljs-type">int</span> u = <span class="hljs-number">1</span>;<span class="hljs-comment">// print number of vertices adjacent to u</span>cout &lt;&lt; <span class="hljs-string">&quot;deg(u) = &quot;</span> &lt;&lt; adj.<span class="hljs-built_in">at</span>(u).<span class="hljs-built_in">size</span>() &lt;&lt; endl;<span class="hljs-comment">// print all edges with u as an endpoint</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : adj.<span class="hljs-built_in">at</span>(u)) cout &lt;&lt; <span class="hljs-string">&quot;&#123;&quot;</span> &lt;&lt; u &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot;&#125;&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;&#125;</code></pre></div><h3 id="output">Output</h3><div class="code-wrapper"><pre><code class="hljs text">deg(u) = 3&#123;1, 3&#125;&#123;1, 4&#125;&#123;1, 5&#125;</code></pre></div><h1 id="graph-traversal-图遍历">Graph Traversal  图遍历</h1><p>图遍历算法按照一定的顺序访问图中的所有节点，并且在遍历过程中可以计算一些信息。两种常见的实现方式是深度优先搜索depth first search (DFS) 和广度优先搜索 breadth first search (BFS)。</p><h2 id="前置知识">前置知识</h2><p><a href="Graph%20图.md">Graph 图</a></p><p><a href="使用递归的穷举搜索.md">使用递归的穷举搜索</a></p><h2 id="dfs">DFS</h2><p>深度优先搜索（DFS）是一种直接的图遍历技术。该算法从起始节点开始，通过图的边访问所有从起始节点可达的其他节点。</p><p>深度优先搜索只要发现新的节点，就会一直沿着图中的单一路径进行。之后，它会返回到之前的节点并开始探索图的其他部分。该算法会记录已访问的节点，以确保每个节点只被处理一次。</p><p><video src="dfs_demo.mp4" controls=""><ahref="dfs_demo.mp4">Video</a></video></p><p>在实现 DFS时，我们通常使用一个递归函数来访问顶点，并使用一个数组来存储是否已经访问过某个顶点。</p><h3 id="cpp-1">cpp</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">int</span> n = <span class="hljs-number">6</span>;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n);<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> current_node)</span> </span>&#123;<span class="hljs-keyword">if</span> (visited[current_node]) &#123; <span class="hljs-keyword">return</span>; &#125;visited[current_node] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : adj[current_node]) &#123; <span class="hljs-built_in">dfs</span>(neighbor); &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;adj[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;;adj[<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;adj[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">5</span>&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-comment">// iterate over all connected components in the graph</span><span class="hljs-keyword">if</span> (!visited[i]) &#123; <span class="hljs-built_in">dfs</span>(i); &#125;&#125;&#125;</code></pre></div><h3 id="python-1">python</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> syssys.setrecursionlimit(<span class="hljs-number">10</span>**<span class="hljs-number">5</span>)  <span class="hljs-comment"># Python has a default recursion limit of 1000</span>n = <span class="hljs-number">6</span>visited = [<span class="hljs-literal">False</span>] * nadj = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]adj[<span class="hljs-number">0</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]adj[<span class="hljs-number">1</span>] = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]adj[<span class="hljs-number">2</span>] = [<span class="hljs-number">5</span>]<span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">current_node</span>):visited[current_node] = <span class="hljs-literal">True</span><span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> adj[current_node]:<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[neighbor]:dfs(neighbor)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[i]:dfs(i)</code></pre></div><h2 id="bfs">BFS</h2><p>在广度优先搜索中，我们按照顶点与起始顶点的距离顺序来遍历顶点。</p><p><video src="bfs_demo.mp4" controls=""><ahref="bfs_demo.mp4">Video</a></video></p><p>在实现 BFS 时，我们通常使用一个队列来跟踪下一个要访问的顶点。与 DFS一样，我们也会维护一个数组来存储是否已经访问过某个顶点。 ### cpp</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-keyword">using</span> std::queue;<span class="hljs-keyword">using</span> std::vector;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-type">int</span> n = <span class="hljs-number">6</span>;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n);<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n)</span></span>;adj[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;;adj[<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;adj[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">5</span>&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-comment">// iterate over all connected components in the graph</span><span class="hljs-keyword">if</span> (!visited[i]) &#123;queue&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push</span>(i);visited[i] = <span class="hljs-literal">true</span>;<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-type">int</span> current_node = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : adj[current_node]) &#123;<span class="hljs-keyword">if</span> (!visited[neighbor]) &#123;visited[neighbor] = <span class="hljs-literal">true</span>;q.<span class="hljs-built_in">push</span>(neighbor);&#125;&#125;&#125;&#125;&#125;&#125;</code></pre></div><h3 id="python-2">python</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> dequen = <span class="hljs-number">6</span>adj = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]visited = [<span class="hljs-literal">False</span>] * nadj[<span class="hljs-number">0</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]adj[<span class="hljs-number">1</span>] = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]adj[<span class="hljs-number">2</span>] = [<span class="hljs-number">5</span>]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<span class="hljs-comment"># iterate over all connected components in the graph</span><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[i]:q = deque([i])<span class="hljs-keyword">while</span> q:node = q.popleft()visited[node] = <span class="hljs-literal">True</span><span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> adj[node]:<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[neighbor]:q.append(neighbor)</code></pre></div><h2 id="应用">应用</h2><h3 id="connected-components-连通分量">Connected Components连通分量</h3><p>https://cses.fi/problemset/task/1666</p><p>一个连通分量是无向图中一个最大的连通节点集合。换句话说，两个节点位于同一个连通分量中，当且仅当它们可以通过图中的边相互到达。</p><p>在上述重点问题中，目标是添加尽可能少的边，使得整个图形成一个单一的连通分量。</p><h4 id="solution---building-roads">Solution - Building Roads</h4><p>请注意，每条边会将连通分量的数量减少零个或一个。因此，您必须至少添加<span class="math inline"><em>C</em> − 1</span> 条边，其中 <spanclass="math inline"><em>C</em></span> 是输入图中的连通分量数量。</p><p>为了计算 <span class="math inline"><em>C</em></span>，可以遍历每个节点。如果该节点尚未被访问，则使用 DFS 或 BFS访问该节点及其所在连通分量的所有其他节点。然后 <spanclass="math inline"><em>C</em></span> 等于我们执行访问操作的次数。</p><p>有许多有效的方法可以选择 <spanclass="math inline"><em>C</em> − 1</span>条新的道路来建设。一种方法是为每个 <spanclass="math inline"><em>C</em></span>连通分量选择一个代表节点，并将它们连接成一条线。</p><h4 id="bfs-1">BFS</h4><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> syssys.setrecursionlimit(<span class="hljs-number">10</span> ** <span class="hljs-number">6</span>)n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())adj = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]visited = [<span class="hljs-literal">False</span>] * n<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):    u, v = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())    u -= <span class="hljs-number">1</span>    v -= <span class="hljs-number">1</span>    adj[u].append(v)    adj[v].append(u)c = <span class="hljs-number">0</span>connect = []<span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>):    visited[node] = <span class="hljs-literal">True</span>    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> adj[node]:        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[v]:            dfs(v)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[i]:        c += <span class="hljs-number">1</span>        connect.append(i)        dfs(i)<span class="hljs-built_in">print</span>(c-<span class="hljs-number">1</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(c-<span class="hljs-number">1</span>):    <span class="hljs-built_in">print</span>(connect[i]+<span class="hljs-number">1</span>, connect[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>)</code></pre></div><h4 id="dfs-1">DFS</h4><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> dequen, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())adj = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]visited = [<span class="hljs-literal">False</span>] * n<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):    u, v = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())    u -= <span class="hljs-number">1</span>    v -= <span class="hljs-number">1</span>    adj[u].append(v)    adj[v].append(u)c = <span class="hljs-number">0</span>connect = []    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[i]:        c += <span class="hljs-number">1</span>        connect.append(i)        q = deque([i])        <span class="hljs-keyword">while</span> q:            node = q.popleft()            visited[node] = <span class="hljs-literal">True</span>            <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> adj[node]:                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[v]:                    q.append(v)<span class="hljs-built_in">print</span>(c-<span class="hljs-number">1</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(c-<span class="hljs-number">1</span>):    <span class="hljs-built_in">print</span>(connect[i]+<span class="hljs-number">1</span>, connect[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>)</code></pre></div><h3 id="graph-two-coloring-图的二色染色">Graph Two-Coloring图的二色染色</h3><p>https://cses.fi/problemset/task/1668</p><p>图的二色化指的是为图中的每个节点分配一个布尔值，该值由边的配置决定。最常见的二色图例子是二分图，在这种图中，每条边连接两个颜色不同的节点。</p><p>在上述重点问题中，目标是将图中的每个节点（朋友）分配到两种颜色（队伍）之一，满足边（友谊）连接两个颜色不同的节点的约束条件。换句话说，我们需要检查输入是否为二分图，如果是，则输出一种有效的着色方案。</p>]]></content>
    
    
    <categories>
      
      <category>Graphs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dfs</tag>
      
      <tag>bfs</tag>
      
      <tag>图搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用递归的穷举搜索</title>
    <link href="/2026/01/30/Graphs/%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E7%9A%84%E7%A9%B7%E4%B8%BE%E6%90%9C%E7%B4%A2/"/>
    <url>/2026/01/30/Graphs/%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E7%9A%84%E7%A9%B7%E4%B8%BE%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="使用递归的穷举搜索">使用递归的穷举搜索</h1><h2 id="subsets-子集">Subsets  子集</h2><p>https://cses.fi/problemset/task/1623</p><h3 id="递归生成子集">递归生成子集</h3><p>编写一个递归函数，遍历所有可能的分组方式。</p><p>在某个索引处，我们要么将 <spanclass="math inline"><code>apple</code><sub><em>i</em></sub></span>​添加到第一个集合，要么添加到第二个集合，存储两个总和 <spanclass="math inline"><code>sum</code><sub>1</sub></span>​ 和 <spanclass="math inline"><code>sum</code><sub>2</sub></span>​，分别表示每个集合中值的总和。</p><p>一旦到达数组的末尾，我们返回这两个总和的差值。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<span class="hljs-type">int</span> n;vector&lt;ll&gt; apples;<span class="hljs-function">ll <span class="hljs-title">sol</span><span class="hljs-params">(<span class="hljs-type">int</span> ind, ll sum1, ll sum2)</span></span>&#123;    <span class="hljs-keyword">if</span>(ind == n)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(sum1 - sum2);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">sol</span>(ind<span class="hljs-number">+1</span>, sum1 + apples[ind], sum2),                <span class="hljs-built_in">sol</span>(ind<span class="hljs-number">+1</span>, sum1, sum2 + apples[ind]));&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);    cin &gt;&gt; n;    apples.<span class="hljs-built_in">resize</span>(n);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;        cin &gt;&gt; apples[i];    &#125;    ll ans = <span class="hljs-built_in">sol</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    cout &lt;&lt; ans;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="permutations-排列">Permutations  排列</h2><ul><li>排列是对一组元素的重新排序。</li><li>Lexicographical Order  字典序</li></ul><p>https://cses.fi/problemset/task/1622</p><h3 id="solution-1递归生成排列">Solution 1：递归生成排列</h3><p>我们将使用递归函数 <spanclass="math inline"><code>search</code></span> 来找出字符串 <spanclass="math inline"><em>s</em></span> 的所有排列。首先，记录 <spanclass="math inline"><em>s</em></span>中每个字符的数量。对于每个函数调用，将一个可用字符添加到当前字符串中，并调用<span class="math inline"><code>search</code></span>以该字符串作为参数。当当前字符串的长度与 <spanclass="math inline"><em>s</em></span>相同时，我们找到了一个排列，可以将其添加到 <spanclass="math inline"><code>perms</code></span> 的列表中。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;string str;vector&lt;string&gt; ans;<span class="hljs-type">int</span> char_count[<span class="hljs-number">26</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">search</span><span class="hljs-params">(string curr)</span></span>&#123;    <span class="hljs-keyword">if</span>(curr.<span class="hljs-built_in">size</span>() == str.<span class="hljs-built_in">size</span>())&#123;        ans.<span class="hljs-built_in">push_back</span>(curr);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)&#123;        <span class="hljs-keyword">if</span>(char_count[i] &gt; <span class="hljs-number">0</span>)&#123;            char_count[i]--;            <span class="hljs-built_in">search</span>(curr + (<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;a&#x27;</span> + i));            char_count[i]++;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);    cin &gt;&gt; str;    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: str)&#123;        char_count[c - <span class="hljs-string">&#x27;a&#x27;</span>] ++;    &#125;    <span class="hljs-built_in">search</span>(<span class="hljs-string">&quot;&quot;</span>);    cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    <span class="hljs-keyword">for</span>(string str: ans)&#123;        cout &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="solution-2使用-next_permutation-生成排列">Solution2：使用 <code>next_permutation</code> 生成排列</h3><p>或者，我们也可以直接使用 <code>next_permutation()</code> 函数。该函数接受一个范围，并将其修改为下一个更大的排列。如果没有更大的排列，它将返回false。</p><p>每次调用 <code>next_permutation</code> 在遍历所有 <spanclass="math inline"><em>N</em>!</span>大小的排列时，平均情况下会进行常数次交换。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);    string s;    cin &gt;&gt; s;    <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());    vector&lt;string&gt; ans;    <span class="hljs-keyword">do</span>&#123;        ans.<span class="hljs-built_in">push_back</span>(s);    &#125; <span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>()));    cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    <span class="hljs-keyword">for</span>(string str: ans)&#123;        cout &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="backtracking-回溯法">Backtracking  回溯法</h2><p>https://cses.fi/problemset/task/1624</p><h3 id="solution-1使用-next_permutation生成排列">Solution1：使用 <code>next_permutation</code>生成排列</h3><p>一种检查所有 <span class="math inline">$\binom{64}{8}$</span>种皇后组合的暴力解法将有超过 40 亿种情况需要检查，因此会太慢。</p><p>我们必须更聪明地进行暴力枚举：注意我们可以直接生成排列，使得任何两个皇后都不在同一行或同一列上互相攻击。</p><p>由于不能有两个皇后在同一列，因此只需要在每一行放置一个皇后。接下来需要确定的是如何变化每个皇后所在的行。这可以通过生成所有排列来实现，其中数字表示每个皇后所在的行。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">int</span> n = <span class="hljs-number">8</span>;vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;<span class="hljs-built_in">blocked</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n));<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">queens</span><span class="hljs-params">(n)</span></span>;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;        <span class="hljs-type">int</span> j = queens[i];        <span class="hljs-keyword">if</span>(blocked[i][j])&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">taken1</span><span class="hljs-params">(n * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;        <span class="hljs-type">int</span> sum = queens[i] + i;        <span class="hljs-keyword">if</span>(taken1[sum])&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        taken1[sum] = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">taken2</span><span class="hljs-params">(n * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;        <span class="hljs-type">int</span> diff = queens[i] - i + n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(taken2[diff])&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        taken2[diff] = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;        string s;        cin &gt;&gt; s;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;            <span class="hljs-keyword">if</span>(s[j] == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;                blocked[i][j] = <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span>&#123;                blocked[i][j] = <span class="hljs-literal">false</span>;            &#125;        &#125;    &#125;        <span class="hljs-built_in">iota</span>(queens.<span class="hljs-built_in">begin</span>(), queens.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">do</span>&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>())&#123;            ans++;        &#125;    &#125; <span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(queens.<span class="hljs-built_in">begin</span>(), queens.<span class="hljs-built_in">end</span>()));    cout &lt;&lt; ans;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="solution-2使用回溯法">Solution 2：使用回溯法</h3><p>回溯算法从一个空解开始，逐步扩展解。搜索递归地遍历所有可能的解的构造方式。</p><p>由于边界条件较小，我们可以递归地回溯所有放置皇后的方式，并存储棋盘的当前状态。</p><p>在每一层，我们尝试在所有未被阻挡或未被其他皇后攻击的格子上放置皇后。完成这一步后，我们递归调用，然后移除该皇后并回溯。</p><p>最后，当我们将八个皇后全部放置完毕时，我们增加答案计数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">int</span> n = <span class="hljs-number">8</span>;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">blocked</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">row_taken</span><span class="hljs-params">(n)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">diag1</span><span class="hljs-params">(<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">diag2</span><span class="hljs-params">(<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">search_queens</span><span class="hljs-params">(<span class="hljs-type">int</span> j)</span></span>&#123;    <span class="hljs-keyword">if</span>(j == n)&#123;        ans++;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;        <span class="hljs-keyword">if</span>(!blocked[i][j] &amp;&amp; !row_taken[i] &amp;&amp; !diag1[i+j] &amp;&amp; ! diag2[i-j+n<span class="hljs-number">-1</span>])&#123;            row_taken[i] = diag1[i+j] = diag2[i-j+n<span class="hljs-number">-1</span>] = <span class="hljs-literal">true</span>;            <span class="hljs-built_in">search_queens</span>(j<span class="hljs-number">+1</span>);            row_taken[i] = diag1[i+j] = diag2[i-j+n<span class="hljs-number">-1</span>] = <span class="hljs-literal">false</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;        string s;        cin &gt;&gt; s;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;            blocked[i][j] = s[j] == <span class="hljs-string">&#x27;*&#x27;</span>;        &#125;    &#125;    <span class="hljs-built_in">search_queens</span>(<span class="hljs-number">0</span>);    cout &lt;&lt; ans;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Graphs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>穷举搜索</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2026/01/29/hello-world/"/>
    <url>/2026/01/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre></div><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo generate</code></pre></div><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo deploy</code></pre></div><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
